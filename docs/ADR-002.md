# ADR-002: Autentisering og tilgangsnivåer

**Status:** Akseptert
**Dato:** 2026-02-07
**Beslutningstagere:** Utviklingsteam
**Kontekst:** Tilgangskontroll for Paragraf MCP-server

---

## Sammendrag

Dette dokumentet beskriver arkitekturbeslutningene for autentisering og tilgangsnivåer i Paragraf MCP-serveren. Formålet er å gi åpen tilgang til lovdata samtidig som registrerte brukere får ubegrenset tilgang.

---

## ADR-002.1: Tilgangsmodell

### Kontekst

MCP-serveren eksponerer offentlig lovdata (NLOD 2.0). Det er ønskelig å holde tjenesten åpen, men beskytte mot misbruk. Samtidig skal registrerte brukere få ubegrenset tilgang uten kostnad.

### Alternativer vurdert

| Alternativ | Friksjon | Beskyttelse | Kompleksitet |
|------------|----------|-------------|--------------|
| A: Helt åpen (ingen auth) | Ingen | Ingen | Minimal |
| B: Kun API-nøkkel (registrering påkrevd) | Høy | God | Lav |
| C: To nivåer (anonym + registrert) | Lav | God | Medium |
| D: Betalt abonnement | Høy | Meget god | Høy |

### Beslutning

**Valgt: Åpent med burst-begrensning (revidert fra C)**

| Brukertype | Auth | Begrensning | Bruksscenario |
|------------|------|-------------|---------------|
| **Alle** | Valgfri | 120 req/min per IP | Alle bruksscenarioer |

Opprinnelig plan var to nivåer (200 oppslag/mnd for anonyme, ubegrenset for API-nøkkel). Dette ble forkastet fordi:

1. **IP ≠ bruker:** CGNAT (mobilnett), universitets-WiFi og VPN gjør IP-basert månedlig kvote meningsløs — én IP kan representere tusenvis av brukere
2. **Månedlig kvote krever persistent state:** Redis eller database for tellere, som øker Supabase-belastning — det motsatte av hensikten
3. **Kvote beskytter ikke mot det faktiske problemet:** En bruker med 199 gjenværende oppslag kan fyre av alle på 1 sekund. Connection pool bryr seg om *samtidighet*, ikke totalt volum

Burst-begrensning (120 req/min per IP) beskytter connection pool uten å ramme delte nettverk. Se ADR-002.6 for detaljer.

### Begrunnelse

- **Lav friksjon:** Ingen registrering, ingen kvote, ingen API-nøkkel påkrevd
- **Offentlige data:** Lovdata er offentlig under NLOD 2.0 — bør være tilgjengelig
- **Riktig beskyttelse:** Burst-limit beskytter Supabase connection pool (60 connections delt med annet prosjekt)
- **Delte nettverk:** 120/min per IP gir plass til ~12 samtidige brukere bak NAT

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Ingen barriere for nye brukere |
| Positiv | Beskytter connection pool mot utilsiktet overbelastning |
| Positiv | Ingen ekstra infrastruktur (in-memory, ingen Redis) |
| Negativ | Per-IP limit kan teoretisk ramme >12 samtidige brukere bak streng NAT |

---

## ADR-002.2: Autentiseringsflyt

### Kontekst

Registrerte brukere trenger en måte å autentisere seg og få en API-nøkkel. Flyten må være enkel nok for ikke-tekniske brukere.

### Alternativer vurdert

| Alternativ | Friksjon | Sikkerhet | Kompleksitet |
|------------|----------|-----------|--------------|
| A: Passord-basert registrering | Medium | Medium | Medium |
| B: Magic link (e-post OTP) | Lav | Høy | Lav |
| C: OAuth (GitHub/Google) | Medium | Høy | Høy |
| D: Selvbetjent API-nøkkel (ingen verifisering) | Minimal | Lav | Minimal |

### Beslutning

**Valgt: B - Magic link via Supabase Auth**

### Flyt

```
1. Bruker -> Landing page -> oppgir e-post
2. Landing page -> supabase.auth.signInWithOtp({ email })
3. Supabase -> sender magic link til bruker
4. Bruker -> klikker lenke -> redirect tilbake til landing page
5. Supabase JS -> onAuthStateChange(SIGNED_IN) -> har JWT
6. Landing page -> POST /mcp/api-keys (med JWT i Authorization header)
7. Backend -> genererer pgf_xxx API-nøkkel -> lagrer i paragraf_api_keys
8. Landing page -> viser API-nøkkel til bruker
```

### Begrunnelse

- **Ingen passord:** Brukere slipper å huske enda et passord
- **Verifisert e-post:** Magic link sikrer at e-postadressen er reell
- **Supabase allerede i bruk:** Prosjektet bruker Supabase for database
- **Enkel frontend:** Kun `signInWithOtp()` + `onAuthStateChange()` - ingen passord-UI

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Ingen passord å vedlikeholde |
| Positiv | Automatisk e-postverifisering |
| Positiv | Gjenbruker eksisterende Supabase-infrastruktur |
| Negativ | Avhengig av at bruker har tilgang til e-post |
| Negativ | Magic link kan havne i spam |

---

## ADR-002.3: API-nøkkelformat og lagring

### Kontekst

Registrerte brukere trenger en vedvarende API-nøkkel de kan bruke i MCP-klienter. Nøkkelen må være enkel å kopiere, gjenkjennbar, og sikker.

### Beslutning

**Format:** `pgf_` + 32 hex-tegn (256 bit entropi)

Eksempel: `pgf_a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4`

### Lagring

```sql
CREATE TABLE paragraf_api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    api_key TEXT NOT NULL UNIQUE,
    name TEXT DEFAULT 'default',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_used_at TIMESTAMPTZ,
    revoked_at TIMESTAMPTZ,
    UNIQUE(user_id, name)
);
```

**RLS-policyer:**
- Brukere kan se egne nøkler (`auth.uid()`)
- Service role (backend) har full tilgang

**Indeks:** Partial indeks på `api_key WHERE revoked_at IS NULL` for rask validering.

### Begrunnelse

- **Prefix `pgf_`:** Gjenkjennbar i logger og konfigurasjon, unngår forveksling med andre tokens
- **256 bit:** Tilstrekkelig entropi for brute-force-motstand
- **Soft delete:** `revoked_at` gjør det mulig å revokere uten å slette historikk
- **Én nøkkel per bruker:** `UNIQUE(user_id, name)` forenkler flyten - returnerer eksisterende nøkkel ved gjentatt forespørsel

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Enkel å gjenkjenne i konfigurasjon |
| Positiv | Soft delete gir audit trail |
| Positiv | Partial indeks gir raske oppslag |
| Negativ | API-nøkkel lagres i klartekst (akseptabelt for dette bruksscenarioet) |

---

## ADR-002.4: Auth-middleware (tri-modus)

### Kontekst

MCP-endepunktet må håndtere tre typer forespørsler: anonyme, API-nøkkel-autentiserte, og JWT-autentiserte (for nøkkeladministrasjon).

### Beslutning

**Valgfri autentisering i `check_mcp_auth()` (before_request):**

| Token | Handling | Resultat |
|-------|----------|----------|
| Ingen | Sett `g.mcp_user = None` | Anonym (rate limited upstream) |
| `Bearer pgf_xxx` | Valider mot `paragraf_api_keys` | Autentisert, ingen rate limit |
| `Bearer <jwt>` | Valider mot Supabase JWT secret | Autentisert (brukes for `/api-keys`) |

### Deteksjonslogikk

```python
token = auth_header[7:]  # Fjern "Bearer "

if token.startswith("pgf_"):
    user = validate_api_key(token)   # Database-oppslag
else:
    user = validate_jwt_token(token)  # HS256 JWT-validering
```

### Begrunnelse

- **Prefix-basert:** `pgf_`-prefix gjør det trivielt å skille API-nøkkel fra JWT uten parsing
- **Alltid tillat anonyme:** Ingen 401 for manglende token - rate limiter håndterer begrensning
- **JWT kun for admin:** JWT brukes kun for `POST /mcp/api-keys`, ikke for daglig MCP-bruk

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Bakoverkompatibelt - eksisterende klienter uten auth fungerer fortsatt |
| Positiv | Prefix-deteksjon er raskere enn token-parsing |
| Negativ | `last_used_at`-oppdatering på hver request gir ekstra database-skriving |

---

## ADR-002.5: Frontend-integrasjon

### Kontekst

Landing page må vise MCP-URL for gratis-brukere og håndtere registreringsflyten for ubegrenset tilgang.

### Beslutning

**Supabase JS-klient med publishable key i frontend.**

| Komponent | Teknologi |
|-----------|-----------|
| Auth-klient | `@supabase/supabase-js` |
| Auth-nøkkel | Publishable key (`sb_publishable_xxx`) |
| MCP-URL | `VITE_MCP_URL` env-variabel |
| API-nøkkel-henting | `fetch(POST /mcp/api-keys)` med JWT |

### Begrunnelse

- **Publishable key:** Trygt å eksponere i frontend - gir kun tilgang til autentiseringsflyt
- **Env-variabel for MCP-URL:** Unngår hardkoding av domene, støtter ulike miljøer
- **`onAuthStateChange`:** Supabase JS håndterer magic link callback automatisk

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Ingen backend-ruter for auth-flyt (Supabase håndterer) |
| Positiv | MCP-URL konfigurerbar per miljø |
| Negativ | Avhengighet til Supabase JS SDK (~100KB gzipped) |

---

## ADR-002.6: Rate limiting

### Kontekst

Paragraf deler Supabase-instans med unified-timeline (60 samtidige connections via pgbouncer). Et script som sender 100 req/sek kan tømme connection pool og ta ned begge prosjektene.

Dataene er offentlige (NLOD 2.0), så rate limiting handler ikke om tilgangskontroll, men om infrastrukturbeskyttelse.

### Alternativer vurdert

| Alternativ | Beskytter pool? | NAT-vennlig? | Ekstra infra? |
|------------|----------------|--------------|---------------|
| A: 200 oppslag/mnd per IP | Nei (burst mulig) | Nei (CGNAT) | Ja (Redis/DB) |
| B: 120 req/min per IP (burst) | Ja | Ja (~12 brukere) | Nei (in-memory) |
| C: Per-bruker kvote (krever auth) | Ja | Ja | Ja (auth + DB) |
| D: Global concurrency-semaphore | Ja | Ja | Nei |

### Beslutning

**Valgt: B — 120 req/min per IP via Flask-Limiter**

Implementert som `@limit_mcp`-decorator i unified-timeline sin `rate_limiter.py`, brukt på MCP POST-endepunktet. Følger eksisterende mønster (`limit_submit`, `limit_webhook`).

### Kapasitetsberegning

```
Supabase connections:     60 (delt)
Paragraf sin andel:       ~30 (konservativt)
Typisk query-tid:         6ms (warm), ~50ms (cold)
Maks throughput:          ~300 req/sek (med sikkermargin)

Legitimt bruksmønster:
  MCP-samtale:            2-5 oppslag over 30 sek → ~10 req/min
  50 studenter på UiO:    50 × 10 = 500 req/min fra én IP → 8.3 req/sek
  120 req/min grense:     Gir plass til ~12 samtidige brukere per IP
```

### Tekniske valg

| Valg | Beslutning | Begrunnelse |
|------|-----------|-------------|
| Storage | `memory://` | Ingen Redis-avhengighet, OK med 1 worker |
| Strategy | `fixed-window` | Lavest ressursbruk |
| Gunicorn | 1 worker, 4 threads | Threads deler minne → rate limits teller korrekt |
| Exempt paths | `/mcp/health`, `/mcp/info` | Ingen DB-query, skal ikke rate-limites |
| API-nøkkel-differensiering | Ingen | Alle brukere får samme limit |
| Degraded mode | Ikke implementert | Prematur — rate limiting er tilstrekkelig |

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Beskytter connection pool med ~10 linjer kode |
| Positiv | Ingen ekstra infrastruktur eller dependencies |
| Positiv | Rate limit state overlever ikke restart — akseptabelt for burst-beskyttelse |
| Negativ | In-memory = mister state ved deploy (akseptabelt) |

---

## Utenfor scope

Følgende er besluttet men ikke implementert ennå:

| Funksjon | Status | Merknad |
|----------|--------|---------|
| Eget domene for MCP-URL | Planlagt | DNS-konfigurasjon |
| API-nøkkel-revokering i UI | Ikke planlagt | Kan gjøres via Supabase Dashboard |

---

## Referanser

- [Supabase Auth - Magic Links](https://supabase.com/docs/guides/auth/passwordless-login/auth-magic-link)
- [ADR-001: Lovdata MCP Arkitektur](./ADR-001.md)
