# ADR-002: Autentisering og tilgangsnivåer

**Status:** Akseptert
**Dato:** 2026-02-07
**Beslutningstagere:** Utviklingsteam
**Kontekst:** Tilgangskontroll for Paragraf MCP-server

---

## Sammendrag

Dette dokumentet beskriver arkitekturbeslutningene for autentisering og tilgangsnivåer i Paragraf MCP-serveren. Formålet er å gi åpen tilgang til lovdata samtidig som registrerte brukere får ubegrenset tilgang.

---

## ADR-002.1: Tilgangsmodell

### Kontekst

MCP-serveren eksponerer offentlig lovdata (NLOD 2.0). Det er ønskelig å holde tjenesten åpen, men beskytte mot misbruk. Samtidig skal registrerte brukere få ubegrenset tilgang uten kostnad.

### Alternativer vurdert

| Alternativ | Friksjon | Beskyttelse | Kompleksitet |
|------------|----------|-------------|--------------|
| A: Helt åpen (ingen auth) | Ingen | Ingen | Minimal |
| B: Kun API-nøkkel (registrering påkrevd) | Høy | God | Lav |
| C: To nivåer (anonym + registrert) | Lav | God | Medium |
| D: Betalt abonnement | Høy | Meget god | Høy |

### Beslutning

**Valgt: C - To nivåer med valgfri autentisering**

| Nivå | Auth | Begrensning | Bruksscenario |
|------|------|-------------|---------------|
| **Gratis** | Ingen (IP-basert) | 200 oppslag/mnd | Utprøving, lavt volum |
| **Ubegrenset** | API-nøkkel (`pgf_xxx`) | Ingen | Daglig bruk, produksjon |

### Begrunnelse

- **Lav friksjon:** Brukere kan teste uten registrering
- **Offentlige data:** Lovdata er offentlig under NLOD 2.0 - bør være tilgjengelig
- **Skalerbarhet:** Rate limiting beskytter mot misbruk uten å stenge ute legitime brukere
- **Ingen kostnad:** Begge nivåer er gratis - registrering gir kun identifisering

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Ingen barriere for nye brukere |
| Positiv | Registrerte brukere får ubegrenset tilgang |
| Negativ | Rate limiting må implementeres separat (utenfor scope) |
| Negativ | IP-basert rate limiting kan ramme delte IP-er (NAT) |

---

## ADR-002.2: Autentiseringsflyt

### Kontekst

Registrerte brukere trenger en måte å autentisere seg og få en API-nøkkel. Flyten må være enkel nok for ikke-tekniske brukere.

### Alternativer vurdert

| Alternativ | Friksjon | Sikkerhet | Kompleksitet |
|------------|----------|-----------|--------------|
| A: Passord-basert registrering | Medium | Medium | Medium |
| B: Magic link (e-post OTP) | Lav | Høy | Lav |
| C: OAuth (GitHub/Google) | Medium | Høy | Høy |
| D: Selvbetjent API-nøkkel (ingen verifisering) | Minimal | Lav | Minimal |

### Beslutning

**Valgt: B - Magic link via Supabase Auth**

### Flyt

```
1. Bruker -> Landing page -> oppgir e-post
2. Landing page -> supabase.auth.signInWithOtp({ email })
3. Supabase -> sender magic link til bruker
4. Bruker -> klikker lenke -> redirect tilbake til landing page
5. Supabase JS -> onAuthStateChange(SIGNED_IN) -> har JWT
6. Landing page -> POST /mcp/api-keys (med JWT i Authorization header)
7. Backend -> genererer pgf_xxx API-nøkkel -> lagrer i paragraf_api_keys
8. Landing page -> viser API-nøkkel til bruker
```

### Begrunnelse

- **Ingen passord:** Brukere slipper å huske enda et passord
- **Verifisert e-post:** Magic link sikrer at e-postadressen er reell
- **Supabase allerede i bruk:** Prosjektet bruker Supabase for database
- **Enkel frontend:** Kun `signInWithOtp()` + `onAuthStateChange()` - ingen passord-UI

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Ingen passord å vedlikeholde |
| Positiv | Automatisk e-postverifisering |
| Positiv | Gjenbruker eksisterende Supabase-infrastruktur |
| Negativ | Avhengig av at bruker har tilgang til e-post |
| Negativ | Magic link kan havne i spam |

---

## ADR-002.3: API-nøkkelformat og lagring

### Kontekst

Registrerte brukere trenger en vedvarende API-nøkkel de kan bruke i MCP-klienter. Nøkkelen må være enkel å kopiere, gjenkjennbar, og sikker.

### Beslutning

**Format:** `pgf_` + 32 hex-tegn (256 bit entropi)

Eksempel: `pgf_a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4`

### Lagring

```sql
CREATE TABLE paragraf_api_keys (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    api_key TEXT NOT NULL UNIQUE,
    name TEXT DEFAULT 'default',
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_used_at TIMESTAMPTZ,
    revoked_at TIMESTAMPTZ,
    UNIQUE(user_id, name)
);
```

**RLS-policyer:**
- Brukere kan se egne nøkler (`auth.uid()`)
- Service role (backend) har full tilgang

**Indeks:** Partial indeks på `api_key WHERE revoked_at IS NULL` for rask validering.

### Begrunnelse

- **Prefix `pgf_`:** Gjenkjennbar i logger og konfigurasjon, unngår forveksling med andre tokens
- **256 bit:** Tilstrekkelig entropi for brute-force-motstand
- **Soft delete:** `revoked_at` gjør det mulig å revokere uten å slette historikk
- **Én nøkkel per bruker:** `UNIQUE(user_id, name)` forenkler flyten - returnerer eksisterende nøkkel ved gjentatt forespørsel

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Enkel å gjenkjenne i konfigurasjon |
| Positiv | Soft delete gir audit trail |
| Positiv | Partial indeks gir raske oppslag |
| Negativ | API-nøkkel lagres i klartekst (akseptabelt for dette bruksscenarioet) |

---

## ADR-002.4: Auth-middleware (tri-modus)

### Kontekst

MCP-endepunktet må håndtere tre typer forespørsler: anonyme, API-nøkkel-autentiserte, og JWT-autentiserte (for nøkkeladministrasjon).

### Beslutning

**Valgfri autentisering i `check_mcp_auth()` (before_request):**

| Token | Handling | Resultat |
|-------|----------|----------|
| Ingen | Sett `g.mcp_user = None` | Anonym (rate limited upstream) |
| `Bearer pgf_xxx` | Valider mot `paragraf_api_keys` | Autentisert, ingen rate limit |
| `Bearer <jwt>` | Valider mot Supabase JWT secret | Autentisert (brukes for `/api-keys`) |

### Deteksjonslogikk

```python
token = auth_header[7:]  # Fjern "Bearer "

if token.startswith("pgf_"):
    user = validate_api_key(token)   # Database-oppslag
else:
    user = validate_jwt_token(token)  # HS256 JWT-validering
```

### Begrunnelse

- **Prefix-basert:** `pgf_`-prefix gjør det trivielt å skille API-nøkkel fra JWT uten parsing
- **Alltid tillat anonyme:** Ingen 401 for manglende token - rate limiter håndterer begrensning
- **JWT kun for admin:** JWT brukes kun for `POST /mcp/api-keys`, ikke for daglig MCP-bruk

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Bakoverkompatibelt - eksisterende klienter uten auth fungerer fortsatt |
| Positiv | Prefix-deteksjon er raskere enn token-parsing |
| Negativ | `last_used_at`-oppdatering på hver request gir ekstra database-skriving |

---

## ADR-002.5: Frontend-integrasjon

### Kontekst

Landing page må vise MCP-URL for gratis-brukere og håndtere registreringsflyten for ubegrenset tilgang.

### Beslutning

**Supabase JS-klient med publishable key i frontend.**

| Komponent | Teknologi |
|-----------|-----------|
| Auth-klient | `@supabase/supabase-js` |
| Auth-nøkkel | Publishable key (`sb_publishable_xxx`) |
| MCP-URL | `VITE_MCP_URL` env-variabel |
| API-nøkkel-henting | `fetch(POST /mcp/api-keys)` med JWT |

### Begrunnelse

- **Publishable key:** Trygt å eksponere i frontend - gir kun tilgang til autentiseringsflyt
- **Env-variabel for MCP-URL:** Unngår hardkoding av domene, støtter ulike miljøer
- **`onAuthStateChange`:** Supabase JS håndterer magic link callback automatisk

### Konsekvenser

| Type | Konsekvens |
|------|------------|
| Positiv | Ingen backend-ruter for auth-flyt (Supabase håndterer) |
| Positiv | MCP-URL konfigurerbar per miljø |
| Negativ | Avhengighet til Supabase JS SDK (~100KB gzipped) |

---

## Utenfor scope

Følgende er besluttet men ikke implementert ennå:

| Funksjon | Status | Merknad |
|----------|--------|---------|
| IP-basert rate limiting (200/mnd) | Planlagt | Flask-Limiter i unified-timeline |
| Eget domene for MCP-URL | Planlagt | DNS-konfigurasjon |
| API-nøkkel-revokering i UI | Ikke planlagt | Kan gjøres via Supabase Dashboard |

---

## Referanser

- [Supabase Auth - Magic Links](https://supabase.com/docs/guides/auth/passwordless-login/auth-magic-link)
- [ADR-001: Lovdata MCP Arkitektur](./ADR-001.md)
